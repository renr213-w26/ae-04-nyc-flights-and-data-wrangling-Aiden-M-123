---
title: "AE 04: NYC flights + data wrangling"
---

```{r}
#| label: load-packages
#| message: false

library(tidyverse)
library(nycflights13)
```

## Exercise 1

```{r}
glimpse(flights)
```


**Your turn:** Fill in the blanks:

The `flights` data frame has 336,776 rows.
Each row represents a flight.

## Exercise 2

**Your turn:** What are the names of the variables in `flights`.

```{r}
#| label: column-names

names(flights)
```

## Exercise 3 - `select()`

-   Make a data frame that only contains the variables `dep_delay` and `arr_delay`.

```{r}
#| label: select-vars

delays <- flights |>
select(dep_delay, arr_delay)
```

-   Make a data frame that keeps every variable except `dep_delay`.

```{r}
#| label: exclude-vars

flights_without_dep_delay <- flights |>
  select(!dep_delay)
```

-   Make a data frame that includes all variables between `year` through `dep_delay` (inclusive). These are all variables that provide information about the departure of each flight.

```{r}
#| label: include-range

depature <- flights |>
  select (year:dep_delay)
```

-   Use the `select` helper `contains()` to make a data frame that includes the variables associated with the arrival, i.e., contains the string `"arr\_"` in the name.

```{r}
#| label: arr-vars

arrival <- flights |>
  select(contains("arr_"))
```

## Exercise 4 - `slice()`

-   Display the first five rows of the `flights` data frame.

```{r}
#| label: slice

flights |>
  slice(1:5)
```

-   Display the last two rows of the `flights` data frame.

```{r}
#| label: last-two

flights |>
  slice((n()-1):n())
```

## Exercise 5 - `arrange()`

-   Let's arrange the data by departure delay, so the flights with the shortest departure delays will be at the top of the data frame.

```{r}
#| label: arrange-delays

flights |>
  arrange(dep_delay)
```

-   Question: What does it mean for the `dep_delay` to have a negative value?

The flight left earlier than scheduled.

-   Arrange the data by descending departure delay, so the flights with the longest departure delays will be at the top.

```{r}
#| label: arrange-delays-desc

flights |>
  arrange(desc(dep_delay))
```

-   **Your turn:** Create a data frame that only includes the plane tail number (`tailnum`), carrier (`carrier`), and departure delay for the flight with the longest departure delay. What is the plane tail number (`tailnum`) for this flight?

```{r}
#| label: longest-delay

longest_delay <- flights |>
  arrange(desc(dep_delay)) |>
  slice(1) |>
  select(tailnum, carrier, dep_delay)

longest_delay
```

## Exercise 6 - `filter()`

-   Filter for all rows where the destination airport is RDU.

```{r}
#| label: rdu

flights |>
  filter(dest == "RDU")
```

-   Filter for all rows where the destination airport is RDU and the arrival delay is less than 0.

```{r}
#| label: rdu-ontime

rdu_ontime <- flights |>
  filter(dest == "RDU", arr_delay < 0)
glimpse(rdu_ontime)
```

-   **Your turn:** Describe what the code is doing in words.

Data frame is being filter to include only flights that arrived at RDU or GSO and that arrived early or departed early. 

```{r}
#| label: nc-early

flights |>
  filter(
    dest %in% c("RDU", "GSO"),
    arr_delay < 0 | dep_delay < 0
  )
```

**Hint:** Logical operators in R:

| operator      | definition                                               |
|:--------------|:---------------------------------------------------------|
| `<`           | is less than?                                            |
| `<=`          | is less than or equal to?                                |
| `>`           | is greater than?                                         |
| `>=`          | is greater than or equal to?                             |
| `==`          | is exactly equal to?                                     |
| `!=`          | is not equal to?                                         |
| `x & y`       | is x AND y?                                              |
| `x \| y`      | is x OR y?                                               |
| `is.na(x)`    | is x NA?                                                 |
| `!is.na(x)`   | is x not NA?                                             |
| `x %in% y`    | is x in y?                                               |
| `!(x %in% y)` | is x not in y?                                           |
| `!x`          | is not x? (only makes sense if `x` is `TRUE` or `FALSE`) |

## Exercise 7 - `count()`

-   Create a frequency table of the destination locations for flights from New York.

```{r}
#| label: count-dest

count_dest <- flights |>
  filter(origin %in% c("JFK", "LGA", "EWR")) |>
  count(dest, sort = TRUE)
count_dest
```

-   In which month was there the fewest number of flights? How many flights were there in that month?

```{r}
#| label: count-month

count_month <- flights |>
  count(month) |>
  arrange(n)
count_month
```

-   **Your turn:** On which date (month + day) was there the largest number of flights? How many flights were there on that day?

```{r}
#| label: count-date

count_date <- flights |>
  count(month, day) |>
  arrange(desc(n))
count_date[1,]
```

## Exercise 8 - `mutate()`

-   Convert `air_time` (minutes in the air) to hours and then create a new variable, `mph`, the miles per hour of the flight.

```{r}
#| label: calculate-mph

flights <- flights |>
  mutate(
    air_hours = air_time / 60,
    mph = distance / air_hours
  )
```

-   **Your turn:** First, count the number of flights each month, and then calculate the proportion of flights in each month. What proportion of flights take place in July?

```{r}
#| label: months-prop

flights_by_month <- flights |>
  count(month) |>
  mutate(prop = n / sum(n))

flights_by_month |>
  filter(month == 7) |>
  mutate(prop.percent = prop *100)
```

-   Create a new variable, `rdu_bound`, which indicates whether the flight is to RDU or not. Then, for each departure airport (`origin`), calculate what proportion of flights originating from that airport are to RDU.

```{r}
#| label: rdu-origin-prop

flights <- flights |>
  mutate(rdu_bound = if_else(dest == "RDU", TRUE, FALSE))
rdu_origin_prop <- flights |>
  group_by(origin) |>
  summarize(prop_to_rdu = mean(rdu_bound, na.rm = TRUE))

rdu_origin_prop
```

## Exercise 9 - `summarize()`

-   Find mean arrival delay for all flights.

```{r}
#| label: find-arrival-delay

flights |>
  summarize(mean_arr_delay = mean(arr_delay, na.rm = TRUE))
```

## Exercise 10 - `group_by()`

-   Find mean arrival delay for for each month.

```{r}
#| label: mean-arr-delay-month

flights |>
  group_by(month) |>
  summarize(arr_delay = mean(arr_delay, na.rm = TRUE))
```

-   **Your turn:** What is the median departure delay for each airports around NYC (`origin`)? Which airport has the shortest median departure delay?

```{r}
#| label: median-dep-dely-origin

median_dep_delay_origin <- flights |>
  group_by(origin) |>
  summarize(median_dep_delay = median(dep_delay, na.rm = TRUE)) |>
  arrange(median_dep_delay)
median_dep_delay_origin
```

# Additional Practice

Try these on your own, either in class if you finish early, or after class.

1.  Create a new dataset that only contains flights that do not have a missing departure time. Include the columns `year`, `month`, `day`, `dep_time`, `dep_delay`, and `dep_delay_hours` (the departure delay in hours). *Hint: Note you may need to use `mutate()` to make one or more of these variables.*

```{r}
#| label: add-practice-1

flights_no_missing <- flights |>
  filter(!is.na(dep_time))
flights_no_missing <- flights_no_missing |>
  mutate(dep_delay_hours = dep_delay /60)
flights_no_missing <- flights_no_missing |>
  select(year, month, day, dep_time, dep_delay,dep_delay_hours)
glimpse(flights_no_missing)
```

2.  For each airplane (uniquely identified by `tailnum`), use a `group_by()` paired with `summarize()` to find the sample size, mean, and standard deviation of flight distances. Then include only the top 5 and bottom 5 airplanes in terms of mean distance traveled per flight in the final data frame.

```{r}
#| label: add-practice-2

stats <- flights |>
  group_by(tailnum) |>
  summarize(
    n_flights = n(),
    mean_distance = mean(distance, na.rm = TRUE), 
    sd_distance = sd(distance, na.rm = TRUE),
  )
    bottom5 <- stats |>
  slice_min(mean_distance, n = 5)
    top5 <- stats |>
  slice_max(mean_distance, n = 5)
 top5
 bottom5
```
